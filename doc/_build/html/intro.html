
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Rusty, a featherweight Rust &#8212; Rusty Logic  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Formal rules" href="judgments.html" />
    <link rel="prev" title="Welcome to Rusty Logic’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section class="tex2jax_ignore mathjax_ignore" id="rusty-a-featherweight-rust">
<h1>Rusty, a featherweight Rust<a class="headerlink" href="#rusty-a-featherweight-rust" title="Permalink to this heading">¶</a></h1>
<p>This section briefly introduces Rusty, a subset of Rust focusing on traits. It is meant for people familiar with PL theory but not Rust in particular.</p>
<section id="notation">
<h2>Notation<a class="headerlink" href="#notation" title="Permalink to this heading">¶</a></h2>
<p>We use an overline <span class="math notranslate nohighlight">\(\overline{S}\)</span> to indicate zero or more instances of the symbol <span class="math notranslate nohighlight">\(S\)</span> (rendered in code as <code class="docutils literal notranslate"><span class="pre">S...</span></code>).
Syntactically it is represented as a comma-separated list (with optional trailing comma).</p>
<p>We reference the following terminals (also called tokens):</p>
<ul class="simple">
<li><p>a struct name <span class="math notranslate nohighlight">\(S\)</span> (rendered in code as <code class="docutils literal notranslate"><span class="pre">S</span></code>)</p></li>
<li><p>a trait name <span class="math notranslate nohighlight">\(T\)</span> (rendered in code as <code class="docutils literal notranslate"><span class="pre">T</span></code>)</p></li>
<li><p>an associated type name <span class="math notranslate nohighlight">\(A\)</span> (rendered in code as <code class="docutils literal notranslate"><span class="pre">A</span></code>)</p></li>
<li><p>a type parameter <span class="math notranslate nohighlight">\(X\)</span> (rendered in code as <code class="docutils literal notranslate"><span class="pre">X</span></code>)</p></li>
</ul>
<p>In the sections that follow we define the following non-terminals:</p>
<ul class="simple">
<li><p>a type name <span class="math notranslate nohighlight">\(\tau\)</span> (rendered in code as <code class="docutils literal notranslate"><span class="pre">t</span></code>)</p></li>
<li><p>a trait definition and Implementations</p></li>
<li><p>a where clause <span class="math notranslate nohighlight">\(W\)</span> (rendered as code as <code class="docutils literal notranslate"><span class="pre">W</span></code>)</p></li>
</ul>
</section>
<section id="types">
<h2>Types<a class="headerlink" href="#types" title="Permalink to this heading">¶</a></h2>
<p>A type <span class="math notranslate nohighlight">\(\tau\)</span> is…</p>
<ul class="simple">
<li><p>a struct <span class="math notranslate nohighlight">\(S\langle\overline{\tau}\rangle\)</span> with type parameters <span class="math notranslate nohighlight">\(\overline{\tau}\)</span></p></li>
<li><p>a tuple <span class="math notranslate nohighlight">\((\overline{\tau})\)</span> of types (with the empty tuple <span class="math notranslate nohighlight">\(()\)</span> representing the unit type)</p></li>
<li><p>an associated type <span class="math notranslate nohighlight">\(A\:\tau\)</span></p></li>
<li><p>a type parameter <span class="math notranslate nohighlight">\(X\)</span></p></li>
</ul>
</section>
<section id="trait-definitions-and-impls-in-rust">
<h2>Trait definitions and impls in Rust<a class="headerlink" href="#trait-definitions-and-impls-in-rust" title="Permalink to this heading">¶</a></h2>
<p>In Rust, a <em>trait <span class="math notranslate nohighlight">\(T\)</span></em> is an interface, declared like so:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">trait</span><span class="w"> </span><span class="n">T</span>: <span class="nc">T_s</span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span> <span class="nc">A</span>: <span class="nc">T_b</span><span class="o">..</span><span class="p">.;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Traits in Rust contain methods and other kinds of members,
but we limit ourselves to the case of exactly one associated type.
The trait definition includes:</p>
<ul class="simple">
<li><p>The trait name <span class="math notranslate nohighlight">\(T\)</span></p></li>
<li><p>A list of “supertraits” <span class="math notranslate nohighlight">\(\overline{T_s}\)</span>. Every type that implements <span class="math notranslate nohighlight">\(T\)</span> must also implement <span class="math notranslate nohighlight">\(\overline{T_s}\)</span>.</p></li>
<li><p>An associated type <span class="math notranslate nohighlight">\(A\)</span>. Every impl of <span class="math notranslate nohighlight">\(T\)</span> must prove a value <span class="math notranslate nohighlight">\(\tau_A\)</span> for <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
<li><p>A list of bounds <span class="math notranslate nohighlight">\(\overline{T_b}\)</span> on <span class="math notranslate nohighlight">\(A\)</span>. The value <span class="math notranslate nohighlight">\(\tau_A\)</span> provided for <span class="math notranslate nohighlight">\(A\)</span> must satisfy the bounds <span class="math notranslate nohighlight">\(\overline{T_b}\)</span>.</p></li>
</ul>
<p>Traits are <em>implemented</em> for a given type <span class="math notranslate nohighlight">\(\tau\)</span> via a <code class="docutils literal notranslate"><span class="pre">impl</span></code>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">X</span><span class="o">..</span><span class="p">.</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">W</span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span> <span class="nc">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t_A</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Implementations in Rust include:</p>
<ul class="simple">
<li><p>A set of type parameters <span class="math notranslate nohighlight">\(\overline{X}\)</span></p></li>
<li><p>The trait <span class="math notranslate nohighlight">\(T\)</span> being implemented</p></li>
<li><p>The self type <span class="math notranslate nohighlight">\(\tau\)</span></p></li>
<li><p>A list of where clauses <span class="math notranslate nohighlight">\(\overline{W}\)</span> which must hold for the impl to apply</p></li>
<li><p>A value <span class="math notranslate nohighlight">\(t_A\)</span> for the associated type <span class="math notranslate nohighlight">\(A\)</span></p></li>
</ul>
</section>
<section id="where-clauses">
<h2>Where clauses<a class="headerlink" href="#where-clauses" title="Permalink to this heading">¶</a></h2>
<p>A provable predicate in our system is a <em>where clause</em> <span class="math notranslate nohighlight">\(W\)</span>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t:</span> <span class="pre">T</span></code> indicates that <span class="math notranslate nohighlight">\(\tau\)</span> implements the trait <span class="math notranslate nohighlight">\(T\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t:</span> <span class="pre">T&lt;A</span> <span class="pre">=</span> <span class="pre">t_1&gt;</span></code> indicates that <span class="math notranslate nohighlight">\(\tau\)</span> implements the trait <span class="math notranslate nohighlight">\(T\)</span> and that the associated type <span class="math notranslate nohighlight">\(A\)</span> is equal to <span class="math notranslate nohighlight">\(\tau_1\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">for&lt;X...&gt;</span> <span class="pre">W</span></code> indicates that <span class="math notranslate nohighlight">\(W\)</span> is provable for all values of <span class="math notranslate nohighlight">\(overline{X}\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">W0</span> <span class="pre">=&gt;</span> <span class="pre">W1</span></code>, not available in Rust today, indicates that <span class="math notranslate nohighlight">\(W_0 \Rightarrow W_1\)</span> (i.e., <span class="math notranslate nohighlight">\(W_0\)</span> being true implies <span class="math notranslate nohighlight">\(W_1\)</span> holds).</p></li>
</ul>
</section>
<section id="special-traits">
<h2>Special traits<a class="headerlink" href="#special-traits" title="Permalink to this heading">¶</a></h2>
<p>The most common use for traits in Rust is to define interfaces, but they are also regularly as markers to indicate sets of types with a particular property. Some traits are special in that they have a specific meaning to the Rust compiler, such as the following:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">Copy</span></code> trait indicates types whose values can safely be copied by simply copying their bits. In logical terms, a value is not affine if its type implements <code class="docutils literal notranslate"><span class="pre">Copy</span></code>. The <code class="docutils literal notranslate"><span class="pre">Copy</span></code> type is implemented like any other trait but, as a special rule, the compiler enforces that this is only permitted if all subfields also implement <code class="docutils literal notranslate"><span class="pre">Copy</span></code>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Send</span></code> and <code class="docutils literal notranslate"><span class="pre">Sync</span></code> traits indicates types whose values can safely be sent between threads and shared between threads, respectively. The next section discusses how they are implemented.</p></li>
</ul>
</section>
<section id="coinductive-auto-traits">
<h2>Coinductive auto traits<a class="headerlink" href="#coinductive-auto-traits" title="Permalink to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Send</span></code> and <code class="docutils literal notranslate"><span class="pre">Sync</span></code> traits introduced in the previous section are the most prominent examples of <em>auto traits</em>. Auto traits are a particular set of traits (not user extensible) for which the compiler automatically adds an implementation. In other words, the compiler automatically decides if a type <span class="math notranslate nohighlight">\(\tau\)</span> implements <em>Send</em>
(unless the user opts out by proving their own impl). The criteria used is that <span class="math notranslate nohighlight">\(\tau\)</span> is <em>Send</em> if all of its field types are <em>Send</em>. The following listing shows a struct <span class="math notranslate nohighlight">\(S\)</span> along with the impl that the compiler would automatically introduce:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">S</span><span class="o">&lt;</span><span class="n">X</span><span class="o">..</span><span class="p">.</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">field_0</span>: <span class="nc">t_0</span><span class="p">,</span>
<span class="w">    </span><span class="o">..</span><span class="p">.</span>
<span class="w">    </span><span class="n">field_N</span>: <span class="nc">t_N</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">X</span><span class="o">..</span><span class="p">.</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">S</span><span class="o">&lt;</span><span class="n">X</span><span class="o">..</span><span class="p">.</span><span class="o">&gt;</span>
<span class="k">where</span>
<span class="w">    </span><span class="n">t_0</span>: <span class="nb">Send</span><span class="p">,</span>
<span class="w">    </span><span class="o">..</span><span class="p">.</span>
<span class="w">    </span><span class="n">t_N</span>: <span class="nb">Send</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// </span>
<span class="p">}</span>
</pre></div>
</div>
<p>Besides having an automatic implementation, auto traits are different from other traits in that they use coinductive semantics.
The need for this arises because of the possibility of cycles between types.
To see this, consider the following (recursive) struct <code class="docutils literal notranslate"><span class="pre">List</span></code>:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">List</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">next</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="c1">//    ^^^^^^ This is a Rust enum, which we have not</span>
<span class="w">    </span><span class="c1">//           included in our Rust subset, but which</span>
<span class="w">    </span><span class="c1">//           are a typical algebraic data type</span>
<span class="w">    </span><span class="c1">//           (structs can be considered an enum with</span>
<span class="w">    </span><span class="c1">//           one variant).</span>
<span class="p">}</span><span class="w">    </span>
</pre></div>
</div>
<p>In this case,</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">List</span></code> is <code class="docutils literal notranslate"><span class="pre">Send</span></code> if <code class="docutils literal notranslate"><span class="pre">Option&lt;Box&lt;List&gt;&gt;</span></code> is <code class="docutils literal notranslate"><span class="pre">Send</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Option&lt;Box&lt;List&gt;&gt;</span></code> is <code class="docutils literal notranslate"><span class="pre">Send</span></code> if <code class="docutils literal notranslate"><span class="pre">Box&lt;List&gt;</span></code> is <code class="docutils literal notranslate"><span class="pre">Send</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Box&lt;List&gt;</span></code> is <code class="docutils literal notranslate"><span class="pre">Send</span></code> if <code class="docutils literal notranslate"><span class="pre">List</span></code> is <code class="docutils literal notranslate"><span class="pre">Send</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">List</span></code> is <code class="docutils literal notranslate"><span class="pre">Send</span></code> because we have a cycle and <code class="docutils literal notranslate"><span class="pre">Send</span></code> is a coinductive trait.</p></li>
</ul>
</section>
<section id="example-programs">
<h2>Example programs<a class="headerlink" href="#example-programs" title="Permalink to this heading">¶</a></h2>
<p>Here are some example programs we’ll use later on.</p>
<section id="hello-world">
<h3>Hello World<a class="headerlink" href="#hello-world" title="Permalink to this heading">¶</a></h3>
</section>
<section id="magic-copy">
<h3>Magic Copy<a class="headerlink" href="#magic-copy" title="Permalink to this heading">¶</a></h3>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Rusty Logic</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Rusty, a featherweight Rust</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#notation">Notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trait-definitions-and-impls-in-rust">Trait definitions and impls in Rust</a></li>
<li class="toctree-l2"><a class="reference internal" href="#where-clauses">Where clauses</a></li>
<li class="toctree-l2"><a class="reference internal" href="#special-traits">Special traits</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coinductive-auto-traits">Coinductive auto traits</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-programs">Example programs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="judgments.html">Formal rules</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to Rusty Logic’s documentation!</a></li>
      <li>Next: <a href="judgments.html" title="next chapter">Formal rules</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2024, Niko Matsakis.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/intro.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>