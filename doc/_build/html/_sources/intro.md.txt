# Rusty, a featherweight Rust

This section briefly introduces Rusty, a subset of Rust focusing on traits. It is meant for people familiar with PL theory but not Rust in particular.

## Notation

We use an overline $\overline{S}$ to indicate zero or more instances of the symbol $S$ (rendered in code as `S...`).
Syntactically it is represented as a comma-separated list (with optional trailing comma).

We reference the following terminals (also called tokens):

* a struct name $S$ (rendered in code as `S`)
* a trait name $T$ (rendered in code as `T`)
* an associated type name $A$ (rendered in code as `A`)
* a type parameter $X$ (rendered in code as `X`)

In the sections that follow we define the following non-terminals:

* a type name $\tau$ (rendered in code as `t`)
* a trait definition and Implementations
* a where clause $W$ (rendered as code as `W`)

## Types


A type $\tau$ is...

* a struct $S\langle\overline{\tau}\rangle$ with type parameters $\overline{\tau}$
* a tuple $(\overline{\tau})$ of types (with the empty tuple $()$ representing the unit type)
* an associated type $A\:\tau$
* a type parameter $X$

## Trait definitions and impls in Rust


In Rust, a *trait $T$* is an interface, declared like so:

```rust
trait T: T_s... {
    type A: T_b...;
}
```

Traits in Rust contain methods and other kinds of members,
but we limit ourselves to the case of exactly one associated type.
The trait definition includes:

* The trait name $T$
* A list of "supertraits" $\overline{T_s}$. Every type that implements $T$ must also implement $\overline{T_s}$.
* An associated type $A$. Every impl of $T$ must prove a value $\tau_A$ for $A$.
* A list of bounds $\overline{T_b}$ on $A$. The value $\tau_A$ provided for $A$ must satisfy the bounds $\overline{T_b}$.

Traits are *implemented* for a given type $\tau$ via a `impl`:

```rust
impl<X...> T for t where W... {
    type A = t_A;
}
```

Implementations in Rust include:

* A set of type parameters $\overline{X}$
* The trait $T$ being implemented
* The self type $\tau$
* A list of where clauses $\overline{W}$ which must hold for the impl to apply
* A value $t_A$ for the associated type $A$

## Where clauses

A provable predicate in our system is a *where clause* $W$:

* `t: T` indicates that $\tau$ implements the trait $T$.
* `t: T<A = t_1>` indicates that $\tau$ implements the trait $T$ and that the associated type $A$ is equal to $\tau_1$.
* `for<X...> W` indicates that $W$ is provable for all values of $overline{X}$.
* `W0 => W1`, not available in Rust today, indicates that $W_0 \Rightarrow W_1$ (i.e., $W_0$ being true implies $W_1$ holds).

## Special traits


The most common use for traits in Rust is to define interfaces, but they are also regularly as markers to indicate sets of types with a particular property. Some traits are special in that they have a specific meaning to the Rust compiler, such as the following:

* The `Copy` trait indicates types whose values can safely be copied by simply copying their bits. In logical terms, a value is not affine if its type implements `Copy`. The `Copy` type is implemented like any other trait but, as a special rule, the compiler enforces that this is only permitted if all subfields also implement `Copy`.
* The `Send` and `Sync` traits indicates types whose values can safely be sent between threads and shared between threads, respectively. The next section discusses how they are implemented.

## Coinductive auto traits

The `Send` and `Sync` traits introduced in the previous section are the most prominent examples of *auto traits*. Auto traits are a particular set of traits (not user extensible) for which the compiler automatically adds an implementation. In other words, the compiler automatically decides if a type $\tau$ implements *Send*
(unless the user opts out by proving their own impl). The criteria used is that $\tau$ is *Send* if all of its field types are *Send*. The following listing shows a struct $S$ along with the impl that the compiler would automatically introduce:

```rust
struct S<X...> {
    field_0: t_0,
    ...
    field_N: t_N,
}

impl<X...> Send for S<X...>
where
    t_0: Send,
    ...
    t_N: Send,
{
    // 
}
```

Besides having an automatic implementation, auto traits are different from other traits in that they use coinductive semantics.
The need for this arises because of the possibility of cycles between types.
To see this, consider the following (recursive) struct `List`:

```rust
struct List {
    next: Option<Box<List>>,
    //    ^^^^^^ This is a Rust enum, which we have not
    //           included in our Rust subset, but which
    //           are a typical algebraic data type
    //           (structs can be considered an enum with
    //           one variant).
}    
```



In this case,

* `List` is `Send` if `Option<Box<List>>` is `Send`,
* `Option<Box<List>>` is `Send` if `Box<List>` is `Send`,
* `Box<List>` is `Send` if `List` is `Send`,
* `List` is `Send` because we have a cycle and `Send` is a coinductive trait.

## Example programs

Here are some example programs we'll use later on.

### Hello World

### Magic Copy
